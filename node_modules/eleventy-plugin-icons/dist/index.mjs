import fs from 'node:fs/promises';
import path from 'node:path';
import memoize from 'just-memoize';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';
import kleur from 'kleur';
import extend from 'just-extend';
import typeOf from 'just-typeof';

const log={log(msg){message(msg);},info(msg){message(msg,"warn","blue");},warn(msg){message(msg,"warn","yellow");},error(msg){message(msg,"error","red");}};function message(message2,type="log",color){const prefix="[eleventy-plugin-icons] ";message2=`${prefix}${message2.split(`
`).join(`
${prefix}`)}`,color?console[type](kleur[color](message2)):console[type](message2);}function mergeAttributes(mergeKeys,objects){return objects.reduce((accumulator,object)=>{for(const key of mergeKeys)object[key]&&(accumulator[key]=accumulator[key]?`${accumulator[key]} ${object[key]}`:object[key]);for(const key of Object.keys(object))mergeKeys.includes(key)||(accumulator[key]=object[key]);return accumulator},{})}function attributesToString(attrs){return Object.entries(attrs).map(([key,value])=>`${key}="${value}"`).join(" ")}function stringify(input){const type=typeof input;if(type==="string"||type==="number")return JSON.stringify(input);if(type==="boolean")return input?"true":"false";if(type==="object"){if(input===null)return "null";if(Array.isArray(input)){let children="";for(let i=0,l=input.length;i<l;i++){const value=input[i],child=stringify(value);child!==void 0&&(children+=children?`, ${child}`:child);}return `[${children}]`}else {let children="";for(const property in input){const value=stringify(input[property]);if(value===void 0)continue;const key=stringify(property);children+=children?`, ${key}: ${value}`:`${key}: ${value}`;}return children?`{ ${children} }`:"{}"}}}function get(input,path){if(!input)return;const accessors=[],regex=/(\w+)|\['([^']+)']|\["([^"]+)"]/g;let matches;for(;matches=regex.exec(path);){const property=matches[1]||matches[2]||matches[3];/\d+/.test(property)?accessors.push({type:"array",access:Number.parseInt(property,10)}):accessors.push({type:"object",access:property});}for(const accessor of accessors){if(!input)return;if(accessor.type==="array"&&Array.isArray(input)){const index=accessor.access;if(Number.isNaN(index)||index<0||index>=input.length)return;input=input[index];}else if(accessor.type==="object"&&typeof input=="object"){const property=accessor.access;input=input[property];}else return;if(input===void 0)return}return input}

const parser=new XMLParser({ignoreAttributes:!1,ignoreDeclaration:!0,commentPropName:"#comment",preserveOrder:!0}),builder=new XMLBuilder({ignoreAttributes:!1,commentPropName:"#comment",preserveOrder:!0,format:!0,suppressEmptyNode:!0,unpairedTags:["hr","br","link","meta"]});function parseSVG(raw,attributes,overwrite){const parsed=parser.parse(raw);let svg,existingAttributes={};for(const node of parsed)if("svg"in node){svg=node.svg,":@"in node&&(existingAttributes=node[":@"],existingAttributes=Object.keys(existingAttributes).reduce((accumulator,key)=>(accumulator[key.replace(/^@_/,"")]=existingAttributes[key],accumulator),{}));const newAttributes=mergeAttributes(overwrite?[]:[...new Set([existingAttributes,attributes].flatMap(object=>Object.keys(object)))],[existingAttributes,attributes]);node[":@"]=Object.keys(newAttributes).reduce((accumulator,key)=>(accumulator["@_"+key]=newAttributes[key],accumulator),{});break}return svg||log.error("No SVG element found."),builder.build(parsed)}

var __defProp=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value}):obj[key]=value;var __publicField=(obj,key,value)=>(__defNormalProp(obj,typeof key!="symbol"?key+"":key,value),value);class Icon{constructor(input,options){__publicField(this,"name","");__publicField(this,"source","");__publicField(this,"path","");__publicField(this,"stringified",()=>stringify(this));__publicField(this,"content",memoize(async options=>{try{let content=await fs.readFile(this.path,"utf-8");return content||(log.warn(`Icon ${this.stringified()} appears to be empty.`),content=""),options.icon.transform?await options.icon.transform(content):content}catch{log[options.icon.errorNotFound?"error":"warn"](`Icon ${this.stringified()} not found.`);}}));if(typeof input=="object")this.name=input.name,this.source=input.source;else if(typeof input=="string")if(input.includes(options.icon.delimiter)){const[source,icon]=input.split(options.icon.delimiter);this.name=icon,this.source=source;}else this.name=input,this.source=options.sources.find(source=>source.default===!0)?.name||"",this.source||log.error(`Icon '${input}' lacks a delimiter and no default source is set.`);else log.error(`Invalid input type for Icon constructor: '${typeof input}'.`);const sourceObject=options.sources.find(source=>source.name===this.source);if(sourceObject){const fileName=sourceObject?.getFileName?sourceObject.getFileName(this.name):`${this.name}.svg`;this.path=path.join(sourceObject.path,fileName);}else log.error(`Source '${this.source}' is not defined in options.sources.`);}}const createSprite=memoize(async(icons,options)=>{const symbols=await Promise.all([...new Set(icons||[])].map(async icon=>{const content=await icon.content(options);return content?parseSVG(content,{id:options.icon.id(icon.name,icon.source)},!0).replace(/<svg/,"<symbol").replace(/<\/svg>/,"</symbol>"):""})),symbolsString=[...new Set(symbols.filter(Boolean))].join("");return symbolsString?`<svg ${attributesToString(options.sprite.attributes)}><defs>${symbolsString}</defs></svg>`:""}),getExtraIcons=async options=>{const icons=[],sources=[];if(options.sprite.extraIcons.all===!0)sources.push(...options.sources);else if(Array.isArray(options.sprite.extraIcons.sources))for(const name of options.sprite.extraIcons.sources){const source=options.sources.find(source2=>source2.name===name);source?sources.push(source):log.error(`options.sprite.extraIcons.sources: Source '${name}' is not defined in options.sources.`);}else if(Array.isArray(options.sprite.extraIcons.icons))for(const icon of options.sprite.extraIcons.icons)(!icon.name||!icon.source)&&log.error(`options.sprite.extraIcons.icons: Invalid icon: ${JSON.stringify(icon)}.`),icons.push(new Icon(icon,options));for(const source of sources)for(const file of await fs.readdir(source.path))file.endsWith(".svg")&&icons.push(new Icon({name:file.replace(".svg",""),source:source.name},options));return icons};

class PluginError extends Error{constructor(message){super(`[eleventy-plugin-icons] ${message}`);}}

const defaultOptions={mode:"inline",sources:[],icon:{shortcode:"icon",delimiter:":",transform:async content=>content,class:name=>`icon icon-${name}`,id:name=>`icon-${name}`,attributes:{},attributesBySource:{},overwriteExistingAttributes:!0,errorNotFound:!0},sprite:{shortcode:"spriteSheet",attributes:{class:"sprite-sheet","aria-hidden":"true",xmlns:"http://www.w3.org/2000/svg"},extraIcons:{all:!1,sources:[],icons:[]},writeFile:!1}};function mergeOptions(options){return extend(!0,defaultOptions,options)}class OptionsError extends PluginError{constructor(option,expected,value){super(`options.${option}: expected ${expected.join(" or ")} but received ${typeOf(value)}`);}}class CustomOptionsError extends PluginError{constructor(option,message){super(`options.${option}: ${message}`);}}function validateOptions(options){function validateOption(option,expected,literal){const value=get(options,option);if(literal){if(!expected.includes(value))throw new OptionsError(option,expected.map(x=>JSON.stringify(x)),value)}else if(!expected.includes(typeOf(value)))throw new OptionsError(option,expected,value)}validateOption("mode",["inline","sprite"],!0),validateOption("sources",["array"]);for(let i=0;i<options.sources.length;i++)validateOption(`sources[${i}].name`,["string"]),validateOption(`sources[${i}].path`,["string"]),validateOption(`sources[${i}].default`,["boolean","undefined"]);if(options.sources.filter(source=>source.default===!0).length>1)throw new CustomOptionsError("sources","only one default source is allowed");if(new Set(options.sources.map(source=>source.name)).size!==options.sources.length)throw new CustomOptionsError("sources","source names must be unique");validateOption("icon",["object"]),validateOption("icon.shortcode",["string"]),validateOption("icon.delimiter",["string"]),validateOption("icon.transform",["function"]),validateOption("icon.class",["function"]),validateOption("icon.id",["function"]),validateOption("icon.attributes",["object"]);for(let i=0;i<Object.entries(options.icon.attributes).length;i++){const[key]=Object.entries(options.icon.attributes)[i];validateOption(`icon.attributes['${key}']`,["string"]);}validateOption("icon.attributesBySource",["object"]);for(let i=0;i<Object.entries(options.icon.attributesBySource).length;i++){const[key,value]=Object.entries(options.icon.attributesBySource)[i];validateOption(`icon.attributesBySource['${key}']`,["object"]);for(let j=0;j<Object.entries(value).length;j++){const[k]=Object.entries(value)[i];validateOption(`icon.attributesBySource['${key}']['${k}']`,["string"]);}}validateOption("icon.overwriteExistingAttributes",["boolean"]),validateOption("icon.errorNotFound",["boolean"]),validateOption("sprite",["object"]),validateOption("sprite.shortcode",["string"]),validateOption("sprite.attributes",["object"]),validateOption("sprite.extraIcons",["object"]),validateOption("sprite.extraIcons.all",["boolean"]),validateOption("sprite.extraIcons.sources",["array"]);for(let i=0;i<options.sprite.extraIcons.sources.length;i++)validateOption(`sprite.extraIcons.sources[${i}]`,["string"]);validateOption("sprite.extraIcons.icons",["array"]);for(let i=0;i<options.sprite.extraIcons.icons.length;i++)validateOption(`sprite.extraIcons.icons[${i}]`,["object"]),validateOption(`sprite.extraIcons.icons[${i}].name`,["string"]),validateOption(`sprite.extraIcons.icons[${i}].source`,["string"]);return validateOption("sprite.writeFile",["boolean","string"]),!0}

function index(eleventyConfig,opts){const usedIcons=[];if(opts===null||typeof opts!="object")throw new Error(`options: expected an object but received ${typeof opts}`);const options=mergeOptions(opts);validateOptions(options),eleventyConfig.addAsyncShortcode(options.icon.shortcode,memoize(async function(input,attrs={}){const icon=new Icon(input,options);usedIcons.push(icon);const content=await icon.content(options);if(!content)return "";switch(typeof attrs){case"string":{attrs=JSON.parse(attrs||"{}");break}case"object":{attrs.__keywords&&delete attrs.__keywords;break}}const attributes=mergeAttributes(["class","id"],[attrs,{class:options.icon.class(icon.name,icon.source)},options.icon.attributes||{},options.icon.attributesBySource[icon.source]||{}]);if(options.mode==="inline")return parseSVG(content,attributes,options.icon.overwriteExistingAttributes);if(options.mode==="sprite")return this.page&&(this.page?.icons===void 0&&(this.page.icons=[]),this.page.icons.includes(icon)||this.page.icons.push(icon)),`<svg ${attributesToString(attributes)}><use href="#${options.icon.id(icon.name,icon.source)}"></use></svg>`})),eleventyConfig.addShortcode(options.sprite.shortcode,async function(){return await createSprite([...this?.page?.icons||[],...await getExtraIcons(options)],options)}),typeof options.sprite.writeFile=="string"&&eleventyConfig.on("eleventy.after",async({dir})=>{const sprite=await createSprite([...usedIcons,...await getExtraIcons(options)],options),file=path.join(dir.output,options.sprite.writeFile),fileDirectory=path.parse(file).dir;try{await fs.readdir(fileDirectory);}catch{await fs.mkdir(fileDirectory,{recursive:!0});}await fs.writeFile(file,sprite);});for(const source of options.sources)eleventyConfig.addWatchTarget(source.path);}

export { index as default };
