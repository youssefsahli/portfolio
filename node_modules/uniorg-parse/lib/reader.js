var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Reader_text, _Reader_vfile, _Reader_location, _Reader_offset, _Reader_left, _Reader_right, _Reader_narrows;
import { location } from 'vfile-location';
export class Reader {
    constructor(vfile) {
        _Reader_text.set(this, void 0);
        _Reader_vfile.set(this, void 0);
        _Reader_location.set(this, void 0);
        /// Current cursor position ignoring the narrowing boundaries.
        _Reader_offset.set(this, 0);
        /// Left boundary of the currently active narrowing.
        _Reader_left.set(this, void 0);
        /// Right boundary of the currently active narrowing (exclusive).
        _Reader_right.set(this, void 0);
        /// Array of currently active narrows.
        _Reader_narrows.set(this, []);
        __classPrivateFieldSet(this, _Reader_text, vfile.toString(), "f");
        __classPrivateFieldSet(this, _Reader_left, 0, "f");
        __classPrivateFieldSet(this, _Reader_right, __classPrivateFieldGet(this, _Reader_text, "f").length, "f");
        __classPrivateFieldSet(this, _Reader_vfile, vfile, "f");
        __classPrivateFieldSet(this, _Reader_location, location(vfile), "f");
    }
    message(reason, offset, ruleId) {
        const point = offset !== undefined ? __classPrivateFieldGet(this, _Reader_location, "f").toPoint(offset) : undefined;
        __classPrivateFieldGet(this, _Reader_vfile, "f").message(reason, point, ruleId);
    }
    advance(n) {
        if (!n) {
            // do nothing
        }
        else if (typeof n === 'number') {
            __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, "f") + n, "f");
        }
        else if (typeof n === 'string') {
            if (this.rest().startsWith(n)) {
                __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, "f") + n.length, "f");
            }
            else {
                // TODO: raise?
            }
        }
        else {
            __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, "f") + (n.index + n[0].length), "f");
        }
        return n;
    }
    /**
     * Move cursor backwards.
     */
    backoff(n) {
        __classPrivateFieldSet(this, _Reader_offset, Math.max(__classPrivateFieldGet(this, _Reader_left, "f"), __classPrivateFieldGet(this, _Reader_offset, "f") - n), "f");
    }
    match(regex) {
        return regex.exec(this.rest());
    }
    lookingAt(regex) {
        const m = this.match(regex);
        return m?.index === 0 ? m : null;
    }
    forceMatch(regex) {
        const m = this.match(regex);
        if (!m) {
            throw new Error(`match error: ${regex} against ${JSON.stringify(this.rest())}`);
        }
        return m;
    }
    forceLookingAt(regex) {
        const m = this.lookingAt(regex);
        if (!m) {
            throw new Error(`match (lookingAt) error: ${regex} against ${JSON.stringify(this.rest())}`);
        }
        return m;
    }
    peek(n) {
        return __classPrivateFieldGet(this, _Reader_text, "f").substring(__classPrivateFieldGet(this, _Reader_offset, "f"), __classPrivateFieldGet(this, _Reader_offset, "f") + n);
    }
    line() {
        const rest = this.rest();
        const endl = rest.indexOf('\n');
        return rest.substring(0, endl === -1 ? rest.length : endl + 1);
    }
    rest() {
        return __classPrivateFieldGet(this, _Reader_text, "f").substring(__classPrivateFieldGet(this, _Reader_offset, "f"), __classPrivateFieldGet(this, _Reader_right, "f"));
    }
    /**
     * Returns string at [left, right).
     *
     * Ignores narrowing.
     */
    substring(left, right) {
        return __classPrivateFieldGet(this, _Reader_text, "f").substring(left, right);
    }
    eof() {
        return __classPrivateFieldGet(this, _Reader_offset, "f") >= __classPrivateFieldGet(this, _Reader_right, "f");
    }
    offset() {
        return __classPrivateFieldGet(this, _Reader_offset, "f");
    }
    endOffset() {
        return __classPrivateFieldGet(this, _Reader_right, "f");
    }
    resetOffset(offset) {
        __classPrivateFieldSet(this, _Reader_offset, offset, "f");
    }
    /**
     * Narrows buffer to the region [`left`, `right`).
     *
     * If `preserveOffset` is false (default), also resets cursor to the
     * start of the narrowing region.
     */
    narrow(left, right, preserveOffset = false) {
        __classPrivateFieldGet(this, _Reader_narrows, "f").push({
            prevLeft: __classPrivateFieldGet(this, _Reader_left, "f"),
            prevRight: __classPrivateFieldGet(this, _Reader_right, "f"),
            prevOffset: __classPrivateFieldGet(this, _Reader_offset, "f"),
        });
        __classPrivateFieldSet(this, _Reader_left, left, "f");
        __classPrivateFieldSet(this, _Reader_right, right, "f");
        if (!preserveOffset) {
            __classPrivateFieldSet(this, _Reader_offset, left, "f");
        }
    }
    /**
     * Cancels the previous narrowing operation.
     *
     * If `preserveOffset` is false (default), restores the cursor
     * position that was current when the narrowing was invoked.
     */
    widen(preserveOffset = false) {
        const narrow = __classPrivateFieldGet(this, _Reader_narrows, "f").pop();
        if (narrow) {
            __classPrivateFieldSet(this, _Reader_left, narrow.prevLeft, "f");
            __classPrivateFieldSet(this, _Reader_right, narrow.prevRight, "f");
            if (!preserveOffset) {
                __classPrivateFieldSet(this, _Reader_offset, narrow.prevOffset, "f");
            }
        }
    }
    withNarrow(left, right, f) {
        this.narrow(left, right);
        const result = f();
        this.widen();
        return result;
    }
}
_Reader_text = new WeakMap(), _Reader_vfile = new WeakMap(), _Reader_location = new WeakMap(), _Reader_offset = new WeakMap(), _Reader_left = new WeakMap(), _Reader_right = new WeakMap(), _Reader_narrows = new WeakMap();
//# sourceMappingURL=reader.js.map