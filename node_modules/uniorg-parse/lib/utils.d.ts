import { ParseOptions } from './parse-options.js';
export declare class OrgRegexUtils {
    private options;
    constructor(options: ParseOptions);
    /**
     * Regexp matching a citation key. Key is located in match group “key”.
     */
    citationKeyRe(): RegExp;
    /**
     * Regexp matching a citation prefix. Style, if any, is located in
     * matching group “style”.
     */
    citationPrefixRe(): RegExp;
    linkPlainRe(): string;
    linkTypesRe(): string;
    /**
     * Regexp possibly matching the beginning of an object. This regexp
     * allows false positives. Dedicated parser (e.g.,
     * Parser.parseBold()) will take care of further filtering. Radio
     * links are not matched by this regexp, as they are treated
     * specially in Parser.parseElement().
     */
    objectRe(): RegExp;
    listItemRe(): RegExp;
    fullListItemRe(): RegExp;
    listEndRe(): RegExp;
    paragraphSeparateRe(): RegExp;
    /** The regular expression matching a sub- or superscript. */
    matchSubstringRegex(): RegExp;
    /** A regular expression matching a sub- or superscript, forcing braces. */
    matchSubstringWithBracesRegex(): RegExp;
    /**
     * Compile a regex that matches up to `n` nested groups delimited
     * with `left` and `right`. The content of the outermost group is
     * captured in the regex group `name`.
     *
     * Adapted from `org-create-multibrace-regexp` emacs function.
     */
    multibraceRe(left: string, right: string, n: number, name?: string): string;
    emphRe(): RegExp;
    verbatimRe(): RegExp;
    private emphTemplate;
}
export declare function restrictionFor(type: string): Set<string>;
export declare const greaterElements: Set<string>;
export declare function unescapeCodeInString(s: string): string;
/**
 * Escape characters that have special meaning in the regex. This
 * function returns a regex string that matches `s` literally.
 */
export declare function escapeRegExp(s: string): string;
